\documentclass{article}

\usepackage{amsmath}

\begin{document}

\title{Mit 6.043 - Artificial Intelligence}
\author{Marco Filippone}
\maketitle

\section{Reasoning: goal trees and rule-based expert systems}

A \textbf{semantic net} is a representation in which:
\begin{itemize}
  \item Lexically, there are nodes, links, and application-specific link labels
  \item Structurally, each link conects a tail node to a head node
  \item Semantically, the nodes and links denote application-specific entities
\end{itemize}
With constructors that:
\begin{itemize}
  \item Construct a node
  \item Construct a link, given a link label and two nodes to be connected
\end{itemize}
With readers that:
\begin{itemize}
  \item Produce a list of all links departing from a given node
  \item Produce a list of all links arriving at a given node
  \item Produce a tail node, given a link
  \item Produce a head node, given a link
  \item Produce a link label, given a link
\end{itemize}

A \textbf{Semantic tree} is a representation, that is a semantic net in which:
\begin{itemize}
  \item certain links are called \textbf{branches}. Each banch
    connects two nodes; the head node is called the \textbf{parent
    node} and the tail node is called the \textit{child node}
  \item One node has no parent; it is called the root node.
    Other nodes have exactly one parent
  \item Some nodes have no children, they are called
    \textit{leaf nodes}. When two nodes are connected to each
    other by a chain of two or more branches, one is said to be
    the \textit{ancestor}; the other if said to be the
    descendant
\end{itemize}

With constructors that:
\begin{itemize}
\item Connect a parent node to a child node with a branch links
\end{itemize}
With readers that:
\begin{itemize}
\item Produce a list of a given node's children
\item Produce a given node's parent
\end{itemize}

A \textbf{goal tree} is a semantic tree in which: nodes represent goals and branches indicate how you can achive goals by solving one or more subgoals. Each node's children corresponds to \textbf{immediate subgoals}; each node's parent corresponds to the \textbf{immediate supergoal}. The top node, the one with no parent, is the \textbf{root} goal.

Some goals are satisfied directly, without reference to any other subgoals. These goals are called \textbf{leaf goals}, and the corresponding nodes are called \textbf{leaf nodes}.

Because goal trees always involve \textit{And} nodes, or \textit{Or} nodes, or both. they are often called \textbf{And-Or trees}.

To determine whether a goal has been achieved, you need a testing procedure. The key procedure, \textit{REDUCE}, channels action into the \textit{REDUCE-AND} and the \textit{REDUCE-OR}.

Goal trees enable introspective question answering:
\begin{itemize}
  \item how: the immediate subgoal (downstream) 
  \item why the immediate supergoal (downstream) 
\end{itemize}

\subsection{Eliciting expert systems features}
\begin{itemize}
  \item Heuristic of specific situations: it is dangerous to limit inquiry to office interviews
  \item Heuristic of situation comparison: ask a domain expert for clarification whenever the domain expert's behavior varies in situations that look identical to the knowledge enginner.
  \item You should build a system and see when it cracks. Helps identifiying missing rules.
\end{itemize}

\section{Nets and Basic Search}

A \textbf{search tree} is a representation, that is a semantic tree, in which:
\begin{itemize}
  \item Nodes denote paths
  \item Branches connect paths to one-set path extensions
\end{itemize}
With writers that:
\begin{itemize}
  \item Connect a path to a path description
\end{itemize}
WIth reades that:
\begin{itemize}
  \item Produce a path's description
\end{itemize}

Each child denotes a path that is a one-city extension of the path denoted by its parent.

If a node has \textit{b} children, it is said to have a \textbf{branching}
factor of \textit{b}. If the number of children is always \textit{b}
for every nonleaf node, the the tree is said to have a branching 
factor of \textit{b}.

Each path that does not reach the goal is called a \textbf{partial path}.
Each path that does reach the goal is called a \textbf{complete path},
and the corresponding node is called a \textbf{goal node}.

Nodes are said to be \textbf{open} until they can be expanded,
whereupon they become \textbf{closed}.

\subsection{Blind methods}

\subsubsection{Depth-first Search}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path
    that contains only the root node
  \item Until the first path in the queue terminates at the goal node or the queue is empty,
    \begin{itemize}
      \item Remove the first path from the queue; create new paths
        by extending the first path to all the neighbors of the 
        terminal node
      \item Reject all new paths with loops
      \item Add the new paths, if any to the \textbf{front} of the queue
    \end{itemize}
  \item If the goal node is found, annouce success; otherwise, annouce 
    failure
\end{itemize}

Good when you are confident that all partial paths either reach dead ends
or become complete paths after a reasonable number of steps.

Bad with long or infinite paths, that neither reach dead ends 
nor become complete paths.

\subsubsection{Breadth-first Search}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path
    that contains only the root node
  \item Until the first path in the queue terminates at the goal node 
    or the queue is empty,
    \begin{itemize}
      \item Remove the first path from the queue; create new paths
        by extending the first path to all the neighbors of the 
        terminal node
      \item Reject all new paths with loops
      \item Add the new paths, if any to the \textbf{back} of the queue
    \end{itemize}
  \item If the goal node is found, annouce success; otherwise, annouce 
    failure
\end{itemize}


Works with trees with infinitely deep paths.

Wasteful when all paths lead to the goal node at more or less the same depth.

\subsubsection{Nondeterministic search}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path
    that contains only the root node
  \item Until the first path in the queue terminates at the goal node 
    or the queue is empty,
    \begin{itemize}
      \item Remove the first path from the queue; create new paths
        by extending the first path to all the neighbors of the 
        terminal node
      \item Reject all new paths with loops
      \item Add the new paths \textbf{at random places in the queue}
    \end{itemize}
  \item If the goal node is found, annouce success; otherwise, annouce 
    failure
\end{itemize}

\subsection{Heuristically informed methods}

\subsubsection{Hill climbing}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path
    that contains only the root node
  \item Until the first path in the queue terminates at the goal node 
    or the queue is empty,
    \begin{itemize}
      \item Remove the first path from the queue; create new paths
        by extending the first path to all the neighbors of the 
        terminal node
      \item Reject all new paths with loops
      \item \textbf{Sort the new paths, if any, by the estimated distances 
        between their terminal nodes and the goal}
      \item Add the new paths, if any to the \textbf{front} of the queue
    \end{itemize}
  \item If the goal node is found, annouce success; otherwise, annouce 
    failure
\end{itemize}

Possible issues:
\begin{itemize}
  \item Foothills: an optimal point is found, but it is a local maximum
  \item Plateaus: for all but a small number of positions, all standard-step
    probes leave the quality measurement unchanged
  \item Ridges
\end{itemize}

\subsubsection{Beam search}

Like BFS in that ir progresses level by level. Unlike BFS, beam 
search moves downward only through the best \textit{w} 
nodes at each level; the other nodes are ignored.

\subsubsection{Beast-first search}

While hill climbing demands forward motion from the most recently created
open node. In the best-first seach, \textbf{forward motion is 
from the best open node so far} no matter where that node is i the
partially developed tree.

\subsection{Which search type is good for me?}
\begin{itemize}
  \item Depth-first search is good when unproductive partial
    paths are never too long
  \item Breadth-first search is good when the branching 
    factor is never too large
  \item Nondeterministic search is good when you are not sure whether
    depth-first search or breadth-first search would be better
  \item Hill climbing is good when there is a natural measurement
    of goal distance form each place to the goal and a good path is 
    likely to be among the partial paths that appear to be good at
    all levels
  \item Beam search is good when there is a natural measure of
    goal distance and a good path is likely to be among the 
    partial paths that appear to be good at all levels
  \item Best-first search is good when there is a natural measure 
    of the goal distance and a good partial path may look like
    a bad option before more promising partial paths are played
    out
\end{itemize}

\section{Nets and Optimal Search}

\subsection{British Museum procedure}

Find all possible paths and select the best one from them.

\subsection{Branch and Bound}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path 
    that contains only the root node
  \item Until the first path in the queue terminates at the 
    goal node or the queue is empth:
    \begin{itemize}
      \item Remove the first path from the queue; create new paths 
        by extending the first path to all the neighbors
        of the terminal node
      \item Reject all new paths with loops
      \item add the remaining new paths, if any, to the queue
      \item Sort the entire queue by path length with 
        least-cost paths in front
    \end{itemize}
  \item If the goal node is gound, annouce success; otherwise, 
    annouce failure
\end{itemize}

\subsection{Branch and Bound with lower-bound estimate}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path 
    that contains only the root node
  \item Until the first path in the queue terminates at the 
    goal node or the queue is empth:
    \begin{itemize}
      \item Remove the first path from the queue; create new paths 
        by extending the first path to all the neighbors
        of the terminal node
      \item Reject all new paths with loops
      \item Add the remaining new paths, if any, to the queue
      \item Sort the entire queue by \textbf{the sum of the path
        length and a lower-bound estimate of the cost
        remaining, with least-cost paths in front}
    \end{itemize}
  \item If the goal node is gound, annouce success; otherwise, 
    annouce failure
\end{itemize}

\subsection{Branch and Bound with dynamic programming}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path 
    that contains only the root node
  \item Until the first path in the queue terminates at the 
    goal node or the queue is empth:
    \begin{itemize}
      \item Remove the first path from the queue; create new paths 
        by extending the first path to all the neighbors
        of the terminal node
      \item Reject all new paths with loops
      \item Add the remaining new paths, if any, to the queue
      \item \textbf{if two or more paths reach a common node,
        delete all those paths except the one that reaches the
        common node with the minimum cost}
      \item Sort the entire queue by \textbf{the sum of the path
        length with least-cost paths in front}
    \end{itemize}
  \item If the goal node is gound, annouce success; otherwise, 
    annouce failure
\end{itemize}

\subsection{A* procedure - Branch and bound with Underestimates
and Dynamic Programming}

\begin{itemize}
  \item Form a one-element queue consisting of a zero-length path 
    that contains only the root node
  \item Until the first path in the queue terminates at the 
    goal node or the queue is empth:
    \begin{itemize}
      \item Remove the first path from the queue; create new paths 
        by extending the first path to all the neighbors
        of the terminal node
      \item Reject all new paths with loops
      \item Add the remaining new paths, if any, to the queue
      \item \textbf{if two or more paths reach a common node,
        delete all those paths except the one that reaches the
        common node with the minimum cost}
      \item Sort the entire queue by \textbf{the sum of the path
        length and a lower-bound estimate of the cost
        remaining, with least-cost paths in front}
    \end{itemize}
  \item If the goal node is gound, annouce success; otherwise, 
    annouce failure
\end{itemize}

\subsection{Which optimal search method is good for me?}
\begin{itemize}
  \item The British Museum procedure is good only when the 
    search tree is small
  \item Branch-and-bound search is good when the tree is big 
    and bad paths turn distinctly bad quickly
  \item Branch-and-bound search with a guess is good when 
    there is a good lower-bound estimate of the distance
    remaining to the goal
  \item Dynamic programming is good when many paths convers
    on the same place
  \item The A* procedure is good when both branch-and-bound 
    search with a guess and dynamic programming are good
\end{itemize}

\section{Trees and Adversarial Search}

A \textbf{game tree} is a representation:
\begin{itemize}
  \item Nodes denote board configuration
  \item Branches denote moves
\end{itemize}
With writers that:
\begin{itemize}
  \item Establish that a node is for the maximizer or for
    the minimizer
  \item Connect a board configuration with a board-configuration
    description
\end{itemize}
With readers that:
\begin{itemize}
  \item Determine whether the node if for the minimizer
    or for the maximizer
  \item Produce a board configuration's description
\end{itemize}

\subsection{Min-Max procedure}

\begin{itemize}
  \item If the limit of the search has been reached, compute 
    the static value of the current position relative to the
    appropriate player. Report the result.
  \item Otherwise, if the level is a minimizing level, use
    MINMAX on the children of the current position. Report 
    the minimum of the results
  \item Otherwise, the level is a minimizing level. Use
    MINMAX on the children of the current position. Report 
    the maximum of the results
\end{itemize}

\subsection{Alpha-Beta procedure}

\begin{itemize}
  \item If the level is the top level, let alpha be
    \(-\infty\) and let beta be \(+\infty\)
  \item If the limit of search has been reached, compute the
    static value of the current position relative to the
    appropriate player. Report the result
  \item If the level is a minimizing level:
    \begin{itemize}
      \item Until all children are examined with ALPHA-BETA or
        until alpha is equal to or greater than beta:
        \begin{itemize}
          \item Use ALPHA-BETA procedure, with the current alpha
            and beta values, on a child; note the value reported
          \item Compare the value reported with the beta value;
            if the reported value is smaller, reset beta to the
            new value
          \item Report beta
        \end{itemize}
    \end{itemize}
      \item Otherwise, the level is a maximizing level:
    \begin{itemize}
      \item Until all children are examined with ALPHA-BETA or
        until alpha is equal to or greater than beta:
        \begin{itemize}
          \item Use ALPHA-BETA procedure, with the current alpha
            and beta values, on a child; note the value reported
          \item Compare the value reported with the beta value;
            if the reported value is larger, reset alpha to the
            new value
          \item Report alpha
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Heuristic Methods}

\subsubsection{Progressive deepening}

For each depth level, compute the best move. By doing so, to compute up to level $d-1$ it is necessary to
evaluate:

\begin{math}
  b^0 + b^1 + \cdots + b^{d-1} = \frac{b^d-1}{b-1} \approx b-1
\end{math}

\subsubsection{Forced move heuristic}

The child move involving a \textit{forced move} generally has a
value that stands out from the rest.

\subsubsection{Singular-extension heuristic}

The search should continue as long as one move's static value
stands out.

\subsubsection{Tapered search}

Arrange for the branching factor to vary with depth of
penetration, possibly using tapered search to direct more effort
into the more promising moves.

\section{Symbolic constraints and propagation}

\paragraph{Principle of convergent intelligence} The world
manifest constraints and regularities. If a computer is to
exhibit intelligence, it must exploit those constraints and
regularities, no matter of what the computer happens to be made.

\paragraph{Describe-to-explain principle} The act of detailed
description may turn probabilistic regularities into entirely
deterministic constrains.

\paragraph{Marr's methodological principles}
\begin{enumerate}
  \item Identify the problem
  \item Select or develop an appropriate representation
  \item Expose constraints or regularities
  \item Create particular procedures 
  \item Verify via experiments
\end{enumerate}

\paragraph{Contraction net} is a representation that is a \textit{frame
system}, in which:
\begin{itemize}
  \item Lexically and structurally, certain frame classes
    identify a finite list of application-specific
    interpretations
  \item Procedurally, demon procerures enforce compatibility
    constraints among connected frames
\end{itemize}

\subsection{Applications}

\subsubsection{3D object recognizion in 2D images}

\paragraph{Labeled drawing} is a representation that is a \textit{frame
system}, in which:
\begin{itemize}
  \item Lexically, there are line frames and junctions frames.
    Lines may be convex, cocave, or boundary lines. Junctions may
    be \textit{L}, \textit{Fork}, \textit{T}, or \textit{Arrow}
    junctions
  \item Structurally, junctions frames are connected by line
    frames. Also, each junction frame contains a list of
    interpretation combinations for its connecting lines
  \item Semantically, line frames denotee physical edges.
    Junction frames denote physical vertexes
  \item Procedurally, demon procedures enforce the constraint
    that each junction lavel must be compatible with at least one
    of the junction labels at each of the neighboring junctions
\end{itemize}

\subsubsection{Time-interval relations and scheduling}

\paragraph{Interval net} is a representation that is a
\textit{contraction net}, in which:
\begin{itemize}
  \item Lexically and semantically there are interval frames
    denoting time intervals and lik frames denoting time
    relations: specifically: $\overrightarrow{before}$,
    $\overrightarrow{during}$, $\overrightarrow{overlaps}$,
    $\overrightarrow{meets}$, $\overrightarrow{starts}$,
    $\overrightarrow{finishes}$, $\overrightarrow{is equal to}$,
    and their mirrors
  \item Structurally, interval frames are connected by link
    frames
  \item Procedurally, demon procedures enforce the constraint
    that the interpretations allowed for a link frame between two
    intervals must be consistent with the interpretations allowed
    for the two link frames joining the two intervals to a third
    interval
\end{itemize}
\end{document}
